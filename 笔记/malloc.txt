函数声明(函数原型)： 

void *malloc(int size); 

说明：malloc 向系统申请分配指定size个字节的内存空间。返回类型是 void* 类型。void* 表示未确定类型的指针。C,C++规定，void* 类型可以强制转换为任何其它类型的指针。 

从函数声明上可以看出。malloc 和 new 至少有两个不同: new 返回指定类型的指针，并且可以自动计算所需要大小。比如： 

int *p; 
p = new int; //返回类型为int* 类型(整数型指针)，分配大小为 sizeof(int); 

或： 

int* parr; 
parr = new int [100]; //返回类型为 int* 类型(整数型指针)，分配大小为 sizeof(int) * 100; 

而 malloc 则必须由我们计算要字节数，并且在返回后强行转换为实际类型的指针。 

int* p; 
p = (int *) malloc (sizeof(int)); 

第一、malloc 函数返回的是 void * 类型，如果你写成：p = malloc (sizeof(int)); 则程序无法通过编译，报错：“不能将 void* 赋值给 int * 类型变量”。所以必须通过 (int *) 来将强制转换。 

第二、函数的实参为 sizeof(int) ，用于指明一个整型数据需要的大小。如果你写成：

int* p = (int *) malloc (1); 

代码也能通过编译，但事实上只分配了1个字节大小的内存空间，当你往里头存入一个整数，就会有3个字节无家可归，而直接“住进邻居家”！造成的结果是后面的内存中原有数据内容全部被清空。 

malloc 也可以达到 new [] 的效果，申请出一段连续的内存，方法无非是指定你所需要内存大小。

比如想分配100个int类型的空间： 

int* p = (int *) malloc ( sizeof(int) * 100 ); //分配可以放得下100个整数的内存空间。 

另外有一点不能直接看出的区别是，malloc 只管分配内存，并不能对所得的内存进行初始化，所以得到的一片新内存中，其值将是随机的。 

除了分配及最后释放的方法不一样以外，通过malloc或new得到指针，在其它操作上保持一致。

=============================================

函数malloc()和calloc()都可以用来动态分配内存空间,但两者稍有区别。 

malloc()函数有一个参数,即要分配的内存空间的大小: 

void *malloc(size_t size); 

calloc()函数有两个参数,分别为元素的数目和每个元素的大小,这两个参数的乘积就是要分配的内存空间的大小。 

void *calloc(size_t numElements,size_t sizeOfElement); 

如果调用成功,函数malloc()和函数calloc()都将返回所分配的内存空间的首地址。 

函数malloc()和函数calloc()的主要区别是前者不能初始化所分配的内存空间,而后者能。如果由malloc()函数分配的内存空间原来没有 被使用过，则其中的每一位可能都是0;反之,如果这部分内存曾经被分配过,则其中可能遗留有各种各样的数据。也就是说，使用malloc()函数的程序开 始时(内存空间还没有被重新分配)能正常进行,但经过一段时间(内存空间还已经被重新分配)可能会出现问题。 

函数calloc()会将所分配的内存空间中的每一位都初始化为零,也就是说,如果你是为字符类型或整数类型的元素分配内存,那麽这些元素将保证会被初始 化为0;如果你是为指针类型的元素分配内存,那麽这些元素通常会被初始化为空指针;如果你为实型数据分配内存,则这些元素会被初始化为浮点型的零。 

需要包含头文件： 
#include <malloc.h> 
或

#include<stdlib.h>

函数声明(函数原型)： 

void *malloc(int size); 

说明：malloc 向系统申请分配指定size个字节的内存空间。返回类型是 void* 类型。void* 表示未确定类型的指针。C,C++规定，void* 类型可以强制转换为任何其它类型的指针。 
从函数声明上可以看出。malloc 和 new 至少有两个不同: new 返回指定类型的指针，并且可以自动计算所需要大小。比如： 

int *p; 
p = new int; //返回类型为int* 类型(整数型指针)，分配大小为 sizeof(int); 

或： 

int* parr; 
parr = new int [100]; //返回类型为 int* 类型(整数型指针)，分配大小为 sizeof(int) * 100; 

而 malloc 则必须由我们计算要字节数，并且在返回后强行转换为实际类型的指针。 

int* p; 
p = (int *) malloc (sizeof(int)); 

第一、malloc 函数返回的是 void * 类型，如果你写成：p = malloc (sizeof(int)); 则程序无法通过编译，报错：“不能将 void* 赋值给 int * 类型变量”。所以必须通过 (int *) 来将强制转换。 

第二、函数的实参为 sizeof(int) ，用于指明一个整型数据需要的大小。如果你写成： 

int* p = (int *) malloc (1); 

代码也能通过编译，但事实上只分配了1个字节大小的内存空间，当你往里头存入一个整数，就会有3个字节无家可归，而直接“住进邻居家”！造成的结果是后面的内存中原有数据内容全部被清空。 

malloc 也可以达到 new [] 的效果，申请出一段连续的内存，方法无非是指定你所需要内存大小。 

比如想分配100个int类型的空间： 

int* p = (int *) malloc ( sizeof(int) * 100 ); //分配可以放得下100个整数的内存空间。 

另外有一点不能直接看出的区别是，malloc 只管分配内存，并不能对所得的内存进行初始化，所以得到的一片新内存中，其值将是随机的。 

除了分配及最后释放的方法不一样以外，通过malloc或new得到指针，在其它操作上保持一致。
=============================================

原型：extern void *malloc(unsigned int num_bytes);

用法：#include <malloc.h>

   　或#include<stdlib.h>

功能：分配长度为num_bytes字节的内存块

说明：如果分配成功则返回指向被分配内存的指针，否则返回空指针NULL。

当内存不再使用时，应使用free()函数将内存块释放。

malloc的语法是：指针名=（数据类型*）malloc（长度）,（数据类型*）表示指针.

举例：

// malloc.c

#include <syslib.h>

#include <malloc.h>

main()

{

　　char *p;

　　clrscr(); // clear screen

   　p=(char *)malloc(100);

　　if(p)

　　    printf("Memory Allocated at: %x",p);

　　else

　　    printf("Not Enough Memory!\n");

　　free(p);

　　getchar();

　　return 0;

}

=============================================　　 

malloc（）函数的工作机制
malloc函数的实质体现在，它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。调用malloc函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。调用free函数时，它将用户释放的内存块连接到空闲链上。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块。
